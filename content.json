{"meta":{"title":"无尽光芒g","subtitle":"Na1r的自留地。","description":"网络安全，软件逆向,信息安全","author":"Na1r","url":"https://na1r.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-04-29T00:42:32.006Z","updated":"2020-04-29T00:42:32.005Z","comments":true,"path":"404.html","permalink":"https://na1r.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-04-29T00:41:22.206Z","updated":"2020-04-29T00:41:22.206Z","comments":true,"path":"about/index.html","permalink":"https://na1r.com/about/index.html","excerpt":"","text":"人间不值得。"},{"title":"所有分类","date":"2020-04-29T00:41:38.831Z","updated":"2020-04-29T00:41:38.831Z","comments":true,"path":"categories/index.html","permalink":"https://na1r.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-04-29T00:41:55.857Z","updated":"2020-04-29T00:41:55.857Z","comments":true,"path":"friends/index.html","permalink":"https://na1r.com/friends/index.html","excerpt":"待添加","text":"待添加"},{"title":"","date":"2020-04-28T11:48:53.266Z","updated":"2020-04-28T11:48:53.266Z","comments":true,"path":"mylist/index.html","permalink":"https://na1r.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-04-29T00:42:18.987Z","updated":"2020-04-29T00:42:18.987Z","comments":true,"path":"tags/index.html","permalink":"https://na1r.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ELK学习笔记(一)","slug":"ELK搭建","date":"2020-04-27T15:56:52.000Z","updated":"2020-04-28T13:24:47.817Z","comments":true,"path":"2020/04/27/ELK搭建/","link":"","permalink":"https://na1r.com/2020/04/27/ELK%E6%90%AD%E5%BB%BA/","excerpt":"基础环境 Centos7 关闭Firewalld 12systemctl stop firewalldsystemctl disable firewalld","text":"基础环境 Centos7 关闭Firewalld 12systemctl stop firewalldsystemctl disable firewalld 关闭Selinux 192.168.208.137部署Kibana、ES 192.168.208.138部署Logstash JDK的二进制安装 Jdk1.8二进制包下载路径http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 解压到对应安装目录/usr/local/ 安装命令 123cd &#x2F;usr&#x2F;local&#x2F;tar -zxf jdk-8u201-linux-x64.tar.gz 配置Java环境变量 1234567vi &#x2F;etc&#x2F;profileexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_201&#x2F;export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;binexport CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$CLASSPATH 使配置生效 1source &#x2F;etc&#x2F;profile 验证环境变量 1java -version 验证环境变量 Kibana 下载Kibana二进制包 解压到/usr/local完成安装 Kibana安装脚本 123cd &#x2F;usr&#x2F;localtar -zxf kibana-6.6.0-linux-x86_64.tar.gz 修改Kibana配置 /usr/local/kibana-6.6.0-linux-x86_64/config/kibana.yml 123456789server.port: 5601server.host: &quot;0.0.0.0&quot;#elasticsearch.url: &quot;http:&#x2F;&#x2F;localhost:9200&quot;#elasticsearch.username: &quot;user&quot;#elasticsearch.password: &quot;pass&quot; Kibana的启动和访问 前台启动Kibana：/usr/local/kibana-6.6.0-linux-x86_64/bin/kibana 后台启动Kibana：nohup /usr/local/kibana-6.6.0-linux-x86_64/bin/kibana &gt;/tmp/kibana.log 2&gt;/tmp/kibana.log &amp; 访问Kibana，需要开放5601端口 看到这里就表示Kibana安装成功了 Kibana的安全说明 默认无密码，也是谁都能够访问 如果使用云厂商，可以在安全组控制某个IP的访问 建议借用Nginx实现用户名密码登录 Kibana借用Nginx实现认证 Kibana监听在127.0.0.1 部署Nginx，使用Nginx来转发 Nginx编译安装123456yum install -y lrzsz wget gcc gcc-c++ make pcre pcre-devel zlib zlib-develcd &#x2F;usr&#x2F;local&#x2F;wget &#39;http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.18.0.tar.gz&#39;tar -zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx-1.18.0 &amp;&amp; make &amp;&amp; make install Nginx环境变量设置123vi &#x2F;etc&#x2F;profileexport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;nginx-1.18.0&#x2F;sbin&#x2F;source &#x2F;etc&#x2F;profile Nginx限制源IP访问1vi &#x2F;usr&#x2F;local&#x2F;nginx-1.18.0&#x2F;conf&#x2F;nginx.conf 查看访问日志 /usr/local/nginx-1.18.0/logs/access.log 如果被拒绝了可以在日志里找到源IP 修改Kibana配置/usr/local/kibana-6.6.0-linux-x86_64/config/kibana.yml 重启kibanaps auxfww|grep kibana 重启nginx1nginx -s reload Nginx使用用户名密码1vi &#x2F;usr&#x2F;local&#x2F;nginx-1.18.0&#x2F;conf&#x2F;nginx.conf 12touch htpasswdprintf &quot;username:$(openssl passwd -1 userpwd)\\n&quot; &gt;&#x2F;usr&#x2F;local&#x2F;nginx-1.18.0&#x2F;conf&#x2F;htpasswd 只需要修改username以及userpwd即可 重启nginx1nginx -s reload Elasticsearch部署 解压到对应目录完成安装/usr/local/ Elasticsearch无法用root启动 12cd &#x2F;usr&#x2F;local&#x2F;tar -zxf elasticsearch-6.6.0.tar.gz Elasticsearch配置vi /usr/local/elasticsearch-6.6.0/config/elasticsearch.yml 1234567path.data: &#x2F;usr&#x2F;local&#x2F;elasticsearch-6.6.0&#x2F;datapath.logs: &#x2F;usr&#x2F;local&#x2F;elasticsearch-6.6.0&#x2F;logsnetwork.host: 127.0.0.1http.port: 9200 在生产环境中，一般是采用集群的方式搭建，不建议节点既有资格成为主节点还要存储数据，压力相当大 JVM调优vi elasticsearch-6.6.0/config/jvm.options #默认为1g，建议修改为内存50%,不然容易出现OOM, 由于虚拟机环境配置较低采用128M Elasticsearch的启动需要普通用户启动 1234useradd -s &#x2F;sbin&#x2F;nologin elkchown -R elk:elk &#x2F;usr&#x2F;local&#x2F;elasticsearch-6.6.0&#x2F;su - elk -s &#x2F;bin&#x2F;bash&#x2F;usr&#x2F;local&#x2F;elasticsearch-6.6.0&#x2F;bin&#x2F;elasticsearch -d 是否启动正常 Elasticsearch注意事项 Elasticsearch如果要跨机器通讯，需要监听在真实网卡上 监听在真实网卡需要调整系统参数才能正常启动 Elasticsearch监听在非127.0.0.1 监听在0.0.0.0或者内网地址 vi /usr/local/elasticsearch-6.6.0/config/elasticsearch.yml 最大文件打开数root 权限下 vi /etc/security/limits.conf 1* - nofile 65536 重启Elasticsearchps auxfww /usr/local/elasticsearch-6.6.0/bin/elasticsearch -d 最大打开进程数root权限 vi /etc/security/limits.d/20-nproc.conf 1* - nproc 4096 内核参数vi /etc/sysctl.conf 1vm.max_map_count &#x3D; 262144 sysctl -p 修改完大退重新登陆 切换到elk账户 su - elk -s /bin/bash 1&#x2F;usr&#x2F;local&#x2F;elasticsearch-6.6.0&#x2F;bin&#x2F;elasticsearch -d Elasticsearch监听网卡 模拟环境，建议监听在127.0.0.1 云服务器，9200和9300公网入口限制安全组 自建机房，监听在内网网卡，监听在公网容易被入侵 Elasticsearch操作###Elasticsearch的概念 索引 -&gt;类似于Mysql中的数据库 类型 -&gt;类似于Mysql中的数据表 文档 -&gt;存储数据 Elasticsearch数据操作 curl操作Elasticsearch Kibana操作Elasticsearch 索引创建索引PUT /na1r 获取全部索引GET /_cat/indices?v 删除索引DELETE /na1r Elasticsearch增删改查增 查GET /na1r/users/1 GET /na1r/_search?q=* 改，覆盖 删DELETE /na1r/users/1 修改某个字段不覆盖 使用doc标注修改的内容 修改所有修改前 修改后 增加字段 Logstash部署Logstash安装192.168.208.138部署Logstash 需要Java环境 12cd &#x2F;usr&#x2F;local&#x2F;tar -zxf logstash-6.6.0.tar.gz JVM配置文件由于模拟环境配置较低 vi /usr/local/logstash-6.6.0/config/jvm.options logstash详情Logstash的功能分为接收数据、解析过滤并转换数据、输出数据三个部分， 对应的插件依次是input插件、filter插件、output插件，其中，filter插件是可选的 常用的input -file：读取一个文件，这个读取功能有点类似于Linux的tail命令，一行一行的实时读取 -syslog：监听系统514端口的syslog messages，并使用RFC3164格式进行解析 -redis：Logstash可以从redis服务器读取数据，redis类似一个消息缓存组件 -kafka：从kafka服务器读取数据，与logstash架构配合使用一般用在数据量较大的场景。kafka可作数据的缓冲和存储 -filebeat：文本日志收集器，logstash可以接收filebeat发送过来的数据。 filter filter插件用于数据的过滤、解析和格式化，也就是将非结构化的数据解析成结构化的、可查询的标准化数据。常见filter插件如下： -grok：grok是logstash最重要的插件，可解析并结构化任意数据，支持正则，并提供了很多内置的规则和模板可供使用。 -mutate：此插件提供了丰富的基础类型数据处理能力。包括类型转换、字符串处理和字段处理 -date：用来转换日志记录中的时间字符串 -GeoIP：此插件可以根据ip地址提供对应的地域信息，包括国别，省市，经纬度等，对于可视化地图和区域统计非常有用 output output插件用于数据的输出，一个logstash事件可以穿过多个output，直到所有的output处理完毕，这个事件才结束。输出插件常见的如下： -elasticsearch：发送数据到elasticsearch -file：发送数据到文件 -redis：发送数据到redis中。redis插件可在input和output插件中 -kafka：发送数据到kafka中 Logstash简单的配置vi /usr/local/logstash-6.6.0/config/logstash.conf 12345678input&#123; stdin&#123;&#125;&#125;output&#123; stdout&#123; codec&#x3D;&gt;rubydebug &#125;&#125; Logstash启动 优化启动速度 yum install haveged -y systemctl enable haveged systemctl start haveged 前台启动 /usr/local/logstash-6.6.0/bin/logstash -f /usr/local/logstash-6.6.0/config/logstash.conf 后台启动 nohup /usr/local/logstash-6.6.0/bin/logstash -f /usr/local/logstash-6.6.0/config/logstash.conf &gt;/tmp/logstash.log 2&gt;/tmp/logstash.log &amp; 启动后测试一下 输入：na1r 输出： { “message” =&gt; “na1r”, “@timestamp” =&gt; 2020-04-28T10:20:47.091Z, “@version” =&gt; “1”, “host” =&gt; “localhost.localdomain”} Logstash读取日志 读取登录日志看看 tail -f /var/log/secure vi /usr/local/logstash-6.6.0/config/logstash.conf 12345678910input &#123; file &#123; path &#x3D;&gt; &quot;&#x2F;var&#x2F;log&#x2F;secure&quot; &#125;&#125;output&#123; stdout&#123; codec&#x3D;&gt;rubydebug &#125;&#125; 启动 /usr/local/logstash-6.6.0/bin/logstash -f /usr/local/logstash-6.6.0/config/logstash.conf Logstash读取日志发送到ES用nginx日志试一下 本机安装nginx Nginx编译安装123456yum install -y lrzsz wget gcc gcc-c++ make pcre pcre-devel zlib zlib-develcd &#x2F;usr&#x2F;local&#x2F;wget &#39;http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.18.0.tar.gz&#39;tar -zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx-1.18.0 &amp;&amp; make &amp;&amp; make install Nginx环境变量设置123vi &#x2F;etc&#x2F;profileexport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;nginx-1.18.0&#x2F;sbin&#x2F;source &#x2F;etc&#x2F;profile vi /usr/local/nginx-1.18.0/conf/nginx.conf 开启nginx注：开启nginx可能会出现报错 touch相应的文件然后 nginx -t /usr/local/nginx-1.18.0/sbin/nginx -c /usr/local/nginx-1.18.0/conf/nginx.conf 启动 nginx -s reload 访问 telnet 看看es是不是通的，下图就表示通的。 修改logstash.confvi /usr/local/logstash-6.6.0/config/logstash.conf 12345678910input &#123; file &#123; path &#x3D;&gt; &quot;&#x2F;usr&#x2F;local&#x2F;nginx-1.18.0&#x2F;logs&#x2F;access.log&quot; &#125;&#125;output &#123; elasticsearch &#123; hosts &#x3D;&gt; [&quot;http:&#x2F;&#x2F;192.168.208.137:9200&quot;] &#125;&#125; 启动logstash/usr/local/logstash-6.6.0/bin/logstash -f /usr/local/logstash-6.6.0/config/logstash.conf 看一下nginx日志 访问ES Logstash收集日志 日志文件需要有新日志产生 Logstash跟Elasticsearch要能通讯 Kibana查询数据GET /logstash-xx/_search?q=* 创建索引查看日志 创建完成后点击Discover 日志就比较直观的显示出来了 选择自动刷新时间 可以访问nginx多造一些日志看看 Kibana简单查询 根据字段查询：message: “_msearch” 根据字段查询：选中查询 elk基本入门笔记，后续针对正则表达式学习笔记再整理一下，还有Filebeat以及Redis等","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://na1r.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"elk","slug":"elk","permalink":"https://na1r.com/tags/elk/"},{"name":"日志分析","slug":"日志分析","permalink":"https://na1r.com/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"}]},{"title":"C语言总结小项目-图书管理系统","slug":"C语言总结小项目-图书管理系统","date":"2020-04-06T13:00:52.000Z","updated":"2020-04-28T08:29:26.789Z","comments":true,"path":"2020/04/06/C语言总结小项目-图书管理系统/","link":"","permalink":"https://na1r.com/2020/04/06/C%E8%AF%AD%E8%A8%80%E6%80%BB%E7%BB%93%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"学习软件逆向的第一步，用一个小程序总结一下。","text":"学习软件逆向的第一步，用一个小程序总结一下。 main.h123456789101112131415161718192021222324#pragma once#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Node&#123; char BookName[50]; &#x2F;&#x2F;书名 float BookPrice; &#x2F;&#x2F;价格 int BookNumber; &#x2F;&#x2F;书号 struct Node *next; &#x2F;&#x2F;指向下一个节点的指针&#125;Node;&#x2F;&#x2F;添加Node * AppendNode(Node * head, char * BookName, float BookPrice, int BookNumber);&#x2F;&#x2F;按书名查询void QueryNode(Node * head, char * BookName);&#x2F;&#x2F;按书号查找void QueryNode2(Node * head, int BookNumber);&#x2F;&#x2F;修改void ModifyNode(Node * head, char * BookName, float BookPrice);&#x2F;&#x2F;删除Node * DeleteNode(Node * head, char * BookName);&#x2F;&#x2F;查看全部void AllNode(Node * head); main.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280#include &quot;main.h&quot;int main()&#123; printf(&quot;------图书管理系统------\\n&quot;); Node * head &#x3D; NULL; &#x2F;&#x2F;链表头指针 while (1) &#123; char szBookName[50]; float fBookPrice; float fNewBookPrice; int nBookNumber; int Readflag &#x3D; 0; int Queryflag &#x3D; 0; printf(&quot; 1.添加书籍\\n&quot;); printf(&quot; 2.查询书籍\\n&quot;); printf(&quot; 3.修改书籍\\n&quot;); printf(&quot; 4.删除书籍\\n&quot;); printf(&quot; 5.查看全部\\n&quot;); printf(&quot; 6.退出系统\\n&quot;); printf(&quot;请选择您要使用的功能：\\n&quot;); scanf(&quot;%d&quot;, &amp;Readflag); switch (Readflag) &#123; case 1: &#x2F;&#x2F;添加书籍信息 printf(&quot;请输入书名：\\n&quot;); scanf(&quot;%s&quot;, szBookName); printf(&quot;请输入定价：\\n&quot;); scanf(&quot;%f&quot;, &amp;fBookPrice); printf(&quot;请输入书号：\\n&quot;); scanf(&quot;%d&quot;, &amp;nBookNumber); printf(&quot;添加成功！\\n&quot;); head &#x3D; AppendNode(head, szBookName, fBookPrice, nBookNumber); break; case 2: printf(&quot;请选择查找方式：\\n&quot;); printf(&quot; 1.按书名查找\\n&quot;); printf(&quot; 2.按书号查找\\n&quot;); printf(&quot;请选择需要使用的功能：&quot;); scanf(&quot;%d&quot;, &amp;Queryflag); if (Queryflag &#x3D;&#x3D; 1) &#123; printf(&quot;请输入书名：\\n&quot;); scanf(&quot;%s&quot;, szBookName); QueryNode(head, szBookName); &#125; else if (Queryflag &#x3D;&#x3D; 2) &#123; printf(&quot;请输入书号：\\n&quot;); scanf(&quot;%d&quot;, &amp;nBookNumber); QueryNode2(head, nBookNumber); &#125; break; case 3: printf(&quot;请输入书名：\\n&quot;); scanf(&quot;%s&quot;, szBookName); printf(&quot;请输入新的定价：&quot;); scanf(&quot;%f&quot;,&amp;fNewBookPrice); ModifyNode(head, szBookName, fNewBookPrice); break; case 4: printf(&quot;请输入书名：\\n&quot;); scanf(&quot;%s&quot;, szBookName); printf(&quot;删除成功！\\n&quot;); head &#x3D; DeleteNode(head, szBookName); break; case 5: AllNode(head); break; case 6: exit(0); default: break; &#125; &#125; return 0;&#125;&#x2F;&#x2F;增Node * AppendNode(Node * head, char * BookName, float BookPrice, int BookNumber)&#123; &#x2F;&#x2F;声明一个新的节点 Node * pNewNode &#x3D; NULL; &#x2F;&#x2F;声明一个指向头指针的指针 Node * pHeadNode &#x3D; head; &#x2F;&#x2F;申请一个内存 pNewNode &#x3D; (Node *)malloc(sizeof(Node)); &#x2F;&#x2F;判断内存有没有申请成功 if (pNewNode &#x3D;&#x3D; NULL) &#123; printf(&quot;memory malloc failed!\\n&quot;); exit(0); &#125; if (head &#x3D;&#x3D; NULL) &#123; &#x2F;&#x2F;如果没有头节点，就把头指针指向新申请的内存 head &#x3D; pNewNode; &#125; else &#123; &#x2F;&#x2F;判断有没有到链表结尾 while (pHeadNode-&gt;next !&#x3D; NULL) &#123; pHeadNode &#x3D; pHeadNode-&gt;next; &#125; &#x2F;&#x2F;如果指向最后一个节点就重新指向到新的最后一个节点 pHeadNode-&gt;next &#x3D; pNewNode; &#125; &#x2F;&#x2F;书名 strcpy(pNewNode-&gt;BookName, BookName); &#x2F;&#x2F;定价 pNewNode-&gt;BookPrice &#x3D; BookPrice; &#x2F;&#x2F;书号 pNewNode-&gt;BookNumber &#x3D; BookNumber; &#x2F;&#x2F;把最后一个节点指向NULL pNewNode-&gt;next &#x3D; NULL; return head;&#125;&#x2F;&#x2F;查找void QueryNode(Node * head, char * BookName)&#123; int flag &#x3D; 0; if (head &#x3D;&#x3D; NULL) &#123; printf(&quot;head NULL!\\n&quot;); exit(0); &#125; &#x2F;&#x2F;判断信息是否一致 if (strcmp(BookName,head-&gt;BookName) &#x3D;&#x3D; 0) &#123; printf(&quot;书价\\t书名\\t书号\\n&quot;); printf(&quot;%0.2f\\t%s\\t%d\\n&quot;, head-&gt;BookPrice, head-&gt;BookName, head-&gt;BookNumber); flag &#x3D; 1; &#125; &#x2F;&#x2F;如果不是空 while (head-&gt;next !&#x3D; NULL) &#123; head &#x3D; head-&gt;next; if (strcmp(BookName, head-&gt;BookName) &#x3D;&#x3D; 0) &#123; printf(&quot;书价\\t书名\\t书号\\n&quot;); printf(&quot;%0.2f\\t%s\\t%d\\n&quot;, head-&gt;BookPrice, head-&gt;BookName, head-&gt;BookNumber); flag &#x3D; 1; &#125; &#125; if (flag &#x3D;&#x3D; 0) &#123; printf(&quot;查询失败!!\\n&quot;); &#125; &#125;&#x2F;&#x2F;按书号查找void QueryNode2(Node * head, int BookNumber)&#123; int flag &#x3D; 0; if (head &#x3D;&#x3D; NULL) &#123; printf(&quot;head NULL!\\n&quot;); exit(0); &#125; &#x2F;&#x2F;判断信息是否一致 if (BookNumber &#x3D;&#x3D; head-&gt;BookNumber) &#123; printf(&quot;书价\\t书名\\t书号\\n&quot;); printf(&quot;%0.2f\\t%s\\t%d\\n&quot;, head-&gt;BookPrice, head-&gt;BookName, head-&gt;BookNumber); flag &#x3D; 1; &#125; &#x2F;&#x2F;如果不是空 while (head-&gt;next !&#x3D; NULL) &#123; head &#x3D; head-&gt;next; if (BookNumber &#x3D;&#x3D; head-&gt;BookNumber) &#123; printf(&quot;书价\\t书名\\t书号\\n&quot;); printf(&quot;%0.2f\\t%s\\t%d\\n&quot;, head-&gt;BookPrice, head-&gt;BookName, head-&gt;BookNumber); flag &#x3D; 1; &#125; &#125; if (flag &#x3D;&#x3D; 0) &#123; printf(&quot;查询失败!!\\n&quot;); &#125;&#125;&#x2F;&#x2F;修改void ModifyNode(Node * head, char * BookName, float BookPrice)&#123; int flag &#x3D; 0; float OldPrice;&#x2F;&#x2F;历史价格 if (head &#x3D;&#x3D; NULL) &#123; printf(&quot;head NULL!\\n&quot;); exit(0); &#125; if (strcmp(BookName, head-&gt;BookName) &#x3D;&#x3D; 0) &#123; OldPrice &#x3D; head-&gt;BookPrice;&#x2F;&#x2F;历史价格 head-&gt;BookPrice &#x3D; BookPrice; printf(&quot;成功修改价格!\\n&quot;); printf(&quot;书号\\t书名\\t新书价\\t历史价格\\n&quot;); printf(&quot;%d\\t%s\\t%0.2f\\t%0.2f\\n&quot;, head-&gt;BookNumber, head-&gt;BookName, head-&gt;BookPrice,OldPrice); flag &#x3D; 1; &#125; while (head-&gt;next !&#x3D; NULL) &#123; head &#x3D; head-&gt;next; if (strcmp(BookName, head-&gt;BookName) &#x3D;&#x3D; 0) &#123; OldPrice &#x3D; head-&gt;BookPrice;&#x2F;&#x2F;历史价格 head-&gt;BookPrice &#x3D; BookPrice; printf(&quot;书号\\t书名\\t新书价\\t历史价格\\n&quot;); printf(&quot;%d\\t%s\\t%0.2f\\t%0.2f\\n&quot;, head-&gt;BookNumber, head-&gt;BookName, head-&gt;BookPrice, OldPrice); flag &#x3D; 1; &#125; &#125; if (flag &#x3D;&#x3D; 0) &#123; printf(&quot;查询失败!!\\n&quot;); &#125;&#125;&#x2F;&#x2F;删除Node * DeleteNode(Node * head, char * BookName)&#123; Node * pNode &#x3D; NULL; if (head &#x3D;&#x3D; NULL) &#123; printf(&quot;head NULL!\\n&quot;); exit(0); &#125; if (strcmp(BookName, head-&gt;BookName) &#x3D;&#x3D; 0) &#123; if (head -&gt;next !&#x3D; NULL) &#123; pNode &#x3D; head-&gt;next; free(head); return pNode; &#125; else &#123; printf(&quot;List null!\\n&quot;); return NULL; &#125; &#125; if (strcmp(BookName, head-&gt;next-&gt;BookName) &#x3D;&#x3D; 0) &#123; if (head -&gt;next -&gt;next-&gt;BookName !&#x3D; NULL) &#123; pNode &#x3D; head-&gt;next-&gt;next; head-&gt;next &#x3D; pNode; return head; &#125; &#125; while (head-&gt;next-&gt;next !&#x3D; NULL) &#123; if (strcmp(BookName, head-&gt;next-&gt;next-&gt;BookName) &#x3D;&#x3D; 0) &#123; pNode &#x3D; head-&gt;next-&gt;next-&gt;next; head-&gt;next-&gt;next &#x3D; pNode; return head; &#125; &#125;&#125;&#x2F;&#x2F;查看全部void AllNode(Node * head)&#123; printf(&quot;书号\\t书名\\t定价\\n&quot;); while (head !&#x3D; NULL) &#123; printf(&quot;%d\\t%s\\t%0.2f\\n&quot;, head-&gt;BookNumber, head-&gt;BookName, head-&gt;BookPrice); head &#x3D; head-&gt;next; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://na1r.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://na1r.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"图书","slug":"图书","permalink":"https://na1r.com/tags/%E5%9B%BE%E4%B9%A6/"}]},{"title":"Wireshark流量检测学习","slug":"Wireshark流量检测学习","date":"2020-03-30T15:35:52.000Z","updated":"2020-04-28T08:30:13.879Z","comments":true,"path":"2020/03/30/Wireshark流量检测学习/","link":"","permalink":"https://na1r.com/2020/03/30/Wireshark%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%AD%A6%E4%B9%A0/","excerpt":"Wireshark入门简介Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。","text":"Wireshark入门简介Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。 软件的功能 解决网络故障问题 溯源网络流量 分析网络底层协议 相关软件 科来网络分析系统 Httpwatch Fiddler Sniffer 支持平台 Windows Linux MacOS Wireshark底层框架 GTK1/2：图形处理工具，处理用户的输入输出。 Core：核心引擎，通过函数调用将其他模块连接在一起，起到联动调用的作用。 Wiretap：此时获取的是一些比特流，通过Wiretap（格式支持引擎）能从抓包文件中读取数据包，支持多种文件格式。 Capture：抓包引擎，利用libpcap/WinPcap底层抓取网络数据包，libpcap/WinPcap提供了通用的抓包接口，能从不同类型的网络接口（包括以太网、令牌环网、ATM网等）获取数据包。 Win-/libpcap：Wireshark抓包时依赖的库文件。 Wireshark抓包原理 本地环境 最基本的抓包方式，不借助其他第三方设备，抓取本地网卡进出网络流量，针对自己网卡不能针对整个局域网 集线器环境 同一域，集线器是网络层设备，不学习数据包，广播所有接口（已经很少有这种环境） 交换机环境 镜像端口，将数据拷贝一份到一个端口，交换机端口做SAPN端口镜像操作 ARP欺骗, 假设没有权限在交换机上做端口镜像技术，因为有MAC地址表，又想获取整个局域网中的流量，窃取到其他PC上的流量。这可以通过著名的ARP攻击软件Cain&amp;Abel实现 MAC泛洪 Wireshark下载下载地址：https://www.wireshark.org/ Wireshark 调试功能界面设置Wireshark运行后，界面如下图所示，包括标题栏、菜单栏、工具栏、数据包过滤栏、数据包列表区、数据包详细区、数据包字节区、数据包统计区。 点击“捕获”-&gt;“选项”如下图所示，设置输入接口和过滤器。 数据包详细区是解析数据包核心区域。数据包包含时间流、原始IP地址和目的IP地址、协议、长度、内容等，当双击它能看到对应的详细信息。 列设置列设置包括默认列表、增加列、修改列、隐藏列、删除列，设置默认即可，下图是选中某行右键“应用为列”增加列。 时间设置 也可以右键Time列 数据包合并导出 抓包过滤器 类型（Type） host、net、port 方向（Dir） src、dst 协议（Proto） ether、ip、tcp、udp、http、ftp 逻辑运算符 &amp;&amp; 与 || 或 ! 非 示例：抓取源地址为192.168.1.101，目的端口为80的流量 1src host 192.168.1.101 &amp;&amp; dst port 80 抓取192.168.1.101和192.168.1.102的流量 1host 192.168.1.101 || host 192.168.1.102 不抓取广播包 1! broadcast 过滤IP地址： 123host 192.168.1.101src host 192.168.1.101dst host 192.168.1.101 过滤端口： 1234port 80!port 80dst port 80src port 80 显示过滤器)) 比较符： == 等于 != 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 逻辑操作符： and 两个条件同时满足 or 其中一个条件被满足 xor 有且仅有一个条件被满足 not 没有条件被满足 ip地址： ip.addr ip地址 ip.src 源ip ip.dst 目标ip 端口过滤： tcp.port tcp.srcport tcp.dstport tcp.flags.syn 过滤包含tcp的syn请求的包 tcp.flags.ack 过滤包含tcp的ack应答的包 协议过滤：arp、ip、icmp、udp、tcp、bootp、dns 示例：过滤IP地址： 12ip.addr &#x3D;&#x3D; 192.168.1.101 过滤该地址的包ip.src &#x3D;&#x3D; 172.16.1.101 过滤源地址为该地址的包 过滤端口： 12tcp.port &#x3D;&#x3D; 80 过滤tcp中端口号为80的包tcp.flags.syn &#x3D;&#x3D; 1 过滤syn请求为1的包 Wireshark高级功能数据追踪流主要是将TCP、UDP、SSL数据流进行重组并完整呈现出来 捕获文件属性 专家信息Wireshark会跟在踪捕获文件中发现的任何异常和其他感兴趣的项目，并将其显示在“专家信息”对话框中。目的是让您更好地了解不常见或值得注意的网络行为，并使新手和专家用户比手动扫描数据包列表更快地发现网络问题。 每个专家信息项都有一个严重性级别。从最低到最高使用以下级别。Wireshark使用不同的颜色标记它们，这些颜色显示在括号中： 聊天（蓝色） 有关常规工作流程的信息，例如设置了SYN标志的TCP数据包。 注意（青色） 值得注意的事件，例如应用程序返回了常见的错误代码，例如HTTP 404。 警告（黄色） 警告，例如应用程序返回了异常错误代码，例如连接问题。 错误（红色） 严重的问题，例如格式错误的数据包。 协议分层统计 网络节点及会话统计 针对性的去分析，如流量情况等。 图表分析可以用来进行报告图形化流量展示。 参考文档 [网络安全自学篇] 十三.Wireshark抓包原理（ARP劫持、MAC泛洪）及数据流追踪和图像抓取（二）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://na1r.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Wireshark","slug":"Wireshark","permalink":"https://na1r.com/tags/Wireshark/"},{"name":"流量","slug":"流量","permalink":"https://na1r.com/tags/%E6%B5%81%E9%87%8F/"},{"name":"抓包","slug":"抓包","permalink":"https://na1r.com/tags/%E6%8A%93%E5%8C%85/"}]},{"title":"Webshell检测","slug":"Webshell检测","date":"2020-03-29T13:00:52.000Z","updated":"2020-04-28T08:30:45.099Z","comments":true,"path":"2020/03/29/Webshell检测/","link":"","permalink":"https://na1r.com/2020/03/29/Webshell%E6%A3%80%E6%B5%8B/","excerpt":"WebShell简介Web指的是在web服务器上，而shell是用脚本语言编写的脚本程序，webshell就是就是Web的一个管理工具，可以对web服务器进行操作的权限，也叫webadmin。","text":"WebShell简介Web指的是在web服务器上，而shell是用脚本语言编写的脚本程序，webshell就是就是Web的一个管理工具，可以对web服务器进行操作的权限，也叫webadmin。 webshell一般是被网站管理员用于网站管理、服务器管理等等一些用途，但是由于webshell的功能比较强大，可以上传下载文件，查看数据库，甚至可以调用一些服务器上系统的相关命令（比如创建用户，修改删除文件之类的），通常被黑客利用，黑客通过一些上传方式，将自己编写的webshell上传到web服务器的页面的目录下，然后通过页面访问的形式进行入侵，或者通过插入一句话连接本地的一些相关工具直接对服务器进行入侵操作。 Webshelld分类小马：体积小，代码量少，常见的一句话木马&lt;?php @eval($_POST[&#39;attack&#39;]) ?&gt;，可以通过中国菜刀等工具去连接操作。 大马：体积大，功能齐全；通常会使用系统关键函数 常见的像asp、jsp、php等编程语言编写的shell脚本 WebShell管理工具 中国蚁剑AntSword 中国菜刀 (caidao) 冰蝎 webshell cknife (c刀) xise QuasiBot WeBaCoo Weevely Fastener Altman Webshell-Sniper Webshell检测方法静态检测静态检测指对脚本文件中所使用的特征码，特征值、关键词、高危函数、文件修改的时间、文件权限、文件的所有者以及和其它文件的关联性等多个维度的特征进行检测， 缺点 只能查找已知的webshell 误报率漏报率较高 容易被绕过 优点： 快速方便，对已知的webshell查找准确率高 部署方便 一般情况下需要配合人工 动态检测动态特征检测通过Webshell运行时使用的系统命令或者网络流量及状态的异常来判断动作的威胁程度，Webshell通常会被加密从而避免静态特征的检测，当Webshell运行时就必须向系统发送系统命令来达到控制系统或者操作数据库的目的，通过检测系统调用来监测甚至拦截系统命令被执行，从行为模式上深度检测脚本文件的安全性。 优点： 可用于网站集群，对新型变种脚本有一定的检测能力。 缺点： 针对特定用途的后门较难检测,实施难度较大。 日志分析使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页面的访问数据和数据提交记录。日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，称之为：HTTP异常请求模型检测。例如：一个平时是GET的请求突然有了POST请求并且返回代码为200、某个页面的访问者IP、访问时间具有规律性等。 优点： 采用了一定数据分析的方式，网站的访问量达到一定量级时这种检测方法的结果具有较大参考价值。 缺点： 存在一定误报，对于大量的访问日志，检测工具的处理能力和效率会比较低。 语法检测根据php语言扫描编译的实现方式，进行剥离代码、注释，分析变量、函数、字符串、语言结构的分析方式，来实现关键危险函数的捕捉方式。 变形、窃密型webshell检测基于数据库操作审计的检测方式针对窃密型Webshell必须具有操作数据库的能力，可以引申出一种新的检测方法，通过分析正常WEB脚本文件和窃密型Webshell对数据库操作的差异进行分析是本检测方法所重点研究的方向。正常情况下WEB站点进行数据操作的过程应该是重复性且较为复杂的查询过程，这种查询通常精确度非常高，查询过程不会出现类似于“select * from”这种查询语句。正常的WEB脚本在进行数据库操作的过程中也不会出现跨越数据库查询的情况，一旦出现这种现象基本可以判断为非正常的WEB脚本操作过程。 建立机器学习日志分析系统由于数据库操作记录日志量非常大，使用人工的方法难以进行精确筛选和审计。所以需要建立一套机器自学习的日志审计系统。该日志审计系统主要基于查询模型白名单学习与数学统计模型这两方面进行设计。 Webshell检测工具D盾支持系统:win2003/win2008/win2012/win2016PHP支持:FastCGI/ISAPI (版本:5.x至7.x) 点击下载 | 安装与使用说明 WEBDIR+：需要用户自行上传可疑文件。 支持的文件类型 php, phtml, inc, php3, php4, php5, war, jsp, jspx, asp, aspx, cer, cdx, asa, ashx, asmx, cfm 支持的压缩包 rar, zip, tar, xz, tbz, tgz, tbz2, bz2, gz WebShell Detector可以识别和发现php/cgi(perl)/asp/aspx的shell WEBSHELL.PUBGUI/在线WebShell扫描检测查杀 参考来源 webshell检测方法归纳","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://na1r.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Webshell","slug":"Webshell","permalink":"https://na1r.com/tags/Webshell/"},{"name":"一句话木马","slug":"一句话木马","permalink":"https://na1r.com/tags/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"},{"name":"中国菜刀","slug":"中国菜刀","permalink":"https://na1r.com/tags/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80/"}]},{"title":"分块传输","slug":"分快传输","date":"2019-03-23T02:43:52.000Z","updated":"2019-03-23T02:47:28.000Z","comments":true,"path":"2019/03/23/分快传输/","link":"","permalink":"https://na1r.com/2019/03/23/%E5%88%86%E5%BF%AB%E4%BC%A0%E8%BE%93/","excerpt":"前言分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度。","text":"前言分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度。 数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以及后续应答消息的开始。然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。通常数据块的大小是一致的，但也不总是这种情况。 Transfer-Encoding 分块传输如果存在Transfer-Encoding（重点是chunked），则在header中不能有Content-Length，有也会被忽视。每个块以16进制数值表示当前块的数据大小，然后\\r\\n；再然后是当前chunk的数据内容，接着是\\r\\n；结束块（终止块）是一个常规块，但长度为零。当读取到chunk 的数据大小是0时，意味着请求或响应数据已经分块传输完毕。 例子： 123456789101112131415HTTP&#x2F;1.1 200 OK Content-Type: text&#x2F;plain Transfer-Encoding: chunked7\\r\\n 大小：7字节Mozilla\\r\\n chunk内容9\\r\\n 大小：9字节Developer\\r\\n chunk内容7\\r\\n 大小：7字节Network\\r\\n chunk内容0\\r\\n 结束块，0字节\\r\\n 利用分块传输吊打所有WAF利用分块传输吊打所有WAF Burp suite 分块传输辅助插件https://github.com/c0ny1/chunked-coding-converter 插件编译mvn package 插件使用 参考链接1.https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81 2.https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://na1r.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"过Waf","slug":"过Waf","permalink":"https://na1r.com/tags/%E8%BF%87Waf/"},{"name":"分块传输","slug":"分块传输","permalink":"https://na1r.com/tags/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/"},{"name":"插件","slug":"插件","permalink":"https://na1r.com/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"Kali美化","slug":"kali美化","date":"2019-03-18T14:20:52.000Z","updated":"2019-03-18T14:23:02.000Z","comments":true,"path":"2019/03/18/kali美化/","link":"","permalink":"https://na1r.com/2019/03/18/kali%E7%BE%8E%E5%8C%96/","excerpt":"kali自带的界面太丑了，终于忍不住下手了","text":"kali自带的界面太丑了，终于忍不住下手了 更换主题安装gnome-tweak-tool 1apt-get install gnome-tweak-tool kali主题下载地址 http://gnome-look.org 将下载好的theme放入/usr/share/themes 博主的主题是 https://github.com/vinceliuice/Qogir-theme 使用方式： 1234567git clone https:&#x2F;&#x2F;github.com&#x2F;vinceliuice&#x2F;Qogir-theme.gitsudo apt-get install gtk2-engines-murrine gtk2-engines-pixbufcd Qogir-thme.&#x2F;install 更换图标将下载好的图标文件放入 /usr/share/icons 终端输入gnome-tweaks 搞定！","categories":[{"name":"分享经验","slug":"分享经验","permalink":"https://na1r.com/categories/%E5%88%86%E4%BA%AB%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://na1r.com/tags/Linux/"},{"name":"美化","slug":"美化","permalink":"https://na1r.com/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"服务器加固","slug":"服务器加固","date":"2019-03-11T13:43:52.000Z","updated":"2019-03-11T13:51:02.000Z","comments":true,"path":"2019/03/11/服务器加固/","link":"","permalink":"https://na1r.com/2019/03/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E5%9B%BA/","excerpt":"linux加固一、系统默认账号及组管理 删除系统默认不使用的帐号，包括：lp、mail、games、ftp、nobody、postfix等。删除系统默认不使用的组，包括：mail、games、ftp、nobody、postfix等。","text":"linux加固一、系统默认账号及组管理 删除系统默认不使用的帐号，包括：lp、mail、games、ftp、nobody、postfix等。删除系统默认不使用的组，包括：mail、games、ftp、nobody、postfix等。 二、启用密码策略 密码60天过期，修改密码最小间隔为1天，最短密码要求8，密码过期前7天通知用户。 修改 /etc/login.defs来实现 1234PASS_MAX_DAYS 60PASS_MIN_DAYS 1PASS_MIN_LEN 8PASS_WARN_AGE 7 连续3次输入密码错误，锁定5分钟，主要防止爆破 修改/etc/pam.d/system-auth文件 123auth required pam_env.soauth required pam_tally2.so deny&#x3D;3 unlock_time&#x3D;300 三、SSH安全配置 禁止root登录，禁止空口零登录 修改配置文件 /etc/ssh/sshd_config ssh v1存在缺陷，不能使用这个版本的，应该使用SSH V2 123Protocol 2 #只使用协议版本2PermitRootLogin no #禁止root登录PermitEmptyPasswords no #禁止空口令登录 新建一个用户 useradd testuser ,设置密码 passwd testpass 密码8位以上，使用testuser 登录服务器，在 su到root用户。 重启服务service sshd restart 长时间无人操作自动断开ssh连接 修改配置文件/etc/profile 在末尾加上 1TMOUT&#x3D;300 # 单位是秒 四、禁用所有特殊账户应该从系统中删除所有默认用户和组例如 news,lp,sync,shutdown,uucp,games,halt 等方法：删除账户 userdel name删除组 groupdel name 五、检测监听的端口检测是否有必要开放端口是非常重要的方法：netstat -tulp Apache 加固禁止Apache访问Web目录之外的任何文件编辑 httpd.conf配置文件，修改为： 1234&lt;Directory &#x2F;&gt;Order Deny,AllowDeny from all&lt;&#x2F;Directory&gt; 如果apache必须要访问web目录以外的目录或文件，可以设置可访问目录， 1234&lt;Directory &#x2F;web&gt;Order Allow,DenyAllow from all&lt;&#x2F;Directory&gt; 其中/web为网站根目录。 防止apache列目录(1) 编辑httpd.conf配置文件 123456&lt;Directory &quot;&#x2F;web&quot;&gt;Options FollowSymLinksAllowOverride NoneOrder allow,denyAllow from all&lt;&#x2F;Directory&gt; 将Options Indexes FollowSymLinks中的Indexes去掉，就可以禁止Apache显示该目录结构。Indexes的作用就是当该目录下没有index.html文件时，就显示目录结构。 (2)设置 Apache 的默认页面，编辑%apache%\\conf\\httpd.conf配置文件 123&lt;IfModule dir_module&gt; DirectoryIndex index.html&lt;&#x2F;IfModule&gt; 其中index.html即为默认页面，可根据情况改为其它文件。 (3)重新启动 Apache 服务 MysqlMYSQL权限详细分类全局管理权限： FILE: 在MySQL服务器上读写文件。 PROCESS: 显示或杀死属于其它用户的服务线程。 RELOAD: 重载访问控制表，刷新日志等。 SHUTDOWN: 关闭MySQL服务。 数据库/数据表/数据列权限： ALTER: 修改已存在的数据表(例如增加/删除列)和索引。 CREATE: 建立新的数据库或数据表。 DELETE: 删除表的记录。 DROP: 删除数据表或数据库。 INDEX: 建立或删除索引。 INSERT: 增加表的记录。 SELECT: 显示/搜索表的记录。 UPDATE: 修改表中已存在的记录。 特别的权限： ALL: 允许做任何事(和root一样)。 USAGE: 只允许登录–其它什么也不允许做。 权限控制 账户 权限 登录 root 禁用file权限 仅限localhost user 禁用file权限，禁止新建库 仅限localhost 账户安全权限需求： select, insert, update, delete, alter, create, index 用户授权方法创建用户并仅限本地登录： 1CREATE USER &#39;senna&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; 如果要允许远程登录，则将上述语句中的localhost改为% 比如设置mysql账户senna对数据库user有select，insert，update，delete权限，但没有drop权限，则执行SQL语句： 1GRANT select，insert，update，delete ON USER TO senna@&quot;localhost&quot;; 如果要赋予某用户对某库的所有控制权，则语句为： 1GRANT ALL PRIVILEGES ON USER TO senna@&quot;localhost&quot;; 最后重载授权表：FLUSH PRIVILEGES; 可以适用GRANT语句直接新建mysql账户并完成指定数据库的授权，比如创建一个senna用户，密码为123456，并且只能对user数据库进行操作： 1GRANT ALL ONuser.* TO senna IDENTIFIED BY &quot;123456&quot;; 禁止远程登录限制所有的mysql账户都只能在localhost登录，禁止远程登录。 1update mysql.user set HOST&#x3D;&#39;localhost&#39; 禁用file权限禁用所有mysql账户的file权限。 以root权限登录数据库，执行SQL： 1UPDATE mysql.user SET File_priv &#x3D; &#39;N&#39;; 如果要禁止单个用户的file权限，在上述语句中跟上where子句即可： UPDATE mysql.user SET File_priv = ‘N’; WHERE USER=’root’ 只有root可以新建/删除库，禁用其他mysql账户新建/删除库的权限。 禁止将process或super权限赋给非管理员用户。 修改默认mysql管理员帐号系统mysql的管理员名称是root，一般情况下都没进行修改 执行： update user set user=”fds654dtasd” where user=”root”; flush privileges; 暂时就这些吧，还有好多如nginx、php等还未更新。。。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://na1r.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://na1r.com/tags/Linux/"},{"name":"加固","slug":"加固","permalink":"https://na1r.com/tags/%E5%8A%A0%E5%9B%BA/"},{"name":"mysql","slug":"mysql","permalink":"https://na1r.com/tags/mysql/"}]},{"title":"入侵痕迹清理","slug":"入侵痕迹清理","date":"2019-03-09T08:14:13.000Z","updated":"2019-03-11T13:48:32.000Z","comments":true,"path":"2019/03/09/入侵痕迹清理/","link":"","permalink":"https://na1r.com/2019/03/09/%E5%85%A5%E4%BE%B5%E7%97%95%E8%BF%B9%E6%B8%85%E7%90%86/","excerpt":"登录日志清除以下命令的输出信息里包括了登录用户名、最近登陆时间、IP地址等信。","text":"登录日志清除以下命令的输出信息里包括了登录用户名、最近登陆时间、IP地址等信。 成功登录用户last命令，对应的日志文件/var/log/wtmp 尝试登录信息lastb命令，对应的日志文件/var/log/btmp 显示最近登录信息lastlog命令，对应的日志文件/var/log/lastlog 清空日志文件： 12345echo &gt; &#x2F;var&#x2F;log&#x2F;wtmpecho &gt; &#x2F;var&#x2F;log&#x2F;btmpecho &gt; &#x2F;var&#x2F;log&#x2F;lastlog 清除Bash历史 linux中存放历史命令的文件是.bash_history，清空该文件 1echo &gt; &#x2F;root&#x2F;.bash_history 也可以在输入指令的时候指定Bash不保存历史 &lt;空格&gt;command 清除当前登录session的历史： history -r 清除所有历史： history -cw 在真实的入侵情况下需要处理的日志文件非常多，这里就简单讲一小部分 logtamper一款使用python编写的修改Linux日志工具 1git clone https:&#x2F;&#x2F;github.com&#x2F;re4lity&#x2F;logtamper.git 使用1234567891011躲避管理员w查看python logtamper.py -m 1 -u re4lity -i 192.168.0.188清除指定ip的登录日志python logtamper.py -m 2 -u re4lity -i 192.168.0.188修改上次登录时间地点python logtamper.py -m 3 -u re4lity -i 192.168.0.188 -t tty1 -d 2014:05:28:10:11:12","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://na1r.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"日志清除","slug":"日志清除","permalink":"https://na1r.com/tags/%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4/"},{"name":"linux","slug":"linux","permalink":"https://na1r.com/tags/linux/"}]},{"title":"OWASP Top 10 - 2017","slug":"OWASP Top 10 - 2017","date":"2019-03-02T01:14:13.000Z","updated":"2019-03-11T13:48:54.000Z","comments":true,"path":"2019/03/02/OWASP Top 10 - 2017/","link":"","permalink":"https://na1r.com/2019/03/02/OWASP%20Top%2010%20-%202017/","excerpt":"最近要找工作了，花点时间整理整理知识点补一补。 Top1 注入将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生如SQL注入、OS注入和LDAP（轻量目录访问协议）注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。","text":"最近要找工作了，花点时间整理整理知识点补一补。 Top1 注入将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生如SQL注入、OS注入和LDAP（轻量目录访问协议）注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。 危害：注入可以导致数据丢失或被破坏，缺乏可审计性或拒绝服务。注入漏洞有时甚至可导致完全接管主机。如何防御1234567使用安全的API，避免使用解释器参数化查询转义白名单 Top2 失效的身份认证和会话管理通常，通过错误使用应用程序的身份认证和会话管理功能，攻击者能够破译密码、密钥或绘画令牌，或者利用其它开发缺陷来暂时性或永久性冒充其他用户的身份。 密码管理、超时、密码找回等 危害：可能导致部分甚至全部账户遭受攻击，攻击者一旦成功，攻击者能执行受害用户的任何操作。因此管理员账户、特权账户是常见的攻击目标如何防御1234567账号密码密文传输设置密码和会话有效期，使用强密码限制或逐渐延迟失败的登录尝试SSL Top3 敏感数据泄露许多Web应用程序和API都无法正确的保护敏感数据，例如:财务数据、用户数据等、攻击者可以通过窃取或修改未加密的数据来实施诈骗、身份盗窃等犯罪行为。未加密的敏感数据容易受到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据、存储的数据以及浏览器的交互数据。 如何防御注重保护重要数据，对于员工需要进行安全意识培训。 Top4 XML外部实体（XXE）*XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码 * 危害造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。如何防御123禁止外部实体的解析过滤用户提交的XML数据 Top5 失效的访问控制未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据 危害：例如：访问其他用户的账户、查看敏感文件、修改其他用户的数据、更改访问权限等。如何防御123456789除了公共资源，其他默认拒绝访问。使用一次性的访问控制机制，并在整个应用程序中不断重用它们。禁用Web服务器目录列表，并确保文件元数据不存在于 Web的根目录中。记录失败的访问控制，并在适当时向管理员告警）。当用户注销后，服务器上的JWT令牌应失效。 Top6 安全配置错误安全配置错误是最常见的安全问题，通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的HTTP标头配置以及包含敏感信息的详细信息所造成的。因此我们不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。 危害：系统可能在未知的情况下被完全攻破，用户数据可能随着时间被全部盗走或篡改。甚至导致整个系统被完全破坏如何防御1234567自动化安装部署搭建最小化的平台，不包含任何不必要的功能、组件等。了解并部署每个环节的软件更新和补丁信息。漏洞扫描和安全审计 Top7 跨站脚本（XSS）跨站脚本是最普遍的web应用安全漏洞。当应用程序在发送给浏览器的页面中包含用户提供的数据，但没有经过适当验证和转义，就会导致跨站 危害：攻击者在受害者浏览器中执行脚本以劫持用户会话，插入恶意内容，重定向用户，使用恶意软件劫持用户浏览器等分类反射型：恶意代码并没有保存在目标服务器（目标网站）上，而是攻击者通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击。 DOM型:客户端由浏览器去解析执行。类似反射型XSS。 存储型：恶意代码被保存在目标服务器（目标网站）上，这种攻击具有较强的稳定性和持久性，所有访问镶嵌恶意代码页面的用户都会被攻击。 如何防御123验证输入编码输出（确保输入的字符为数据） Top8 不安全的反序列化*说起反序列化首先要知道序列化是什么，序列化就是把对象转换成字节流，以便于保存在内存、文件数据库中；那反序列化就是逆过程，从字节流还原成对象。所以要利用反序列化漏洞，就需要在进行反序列化的地方传入攻击者的序列化代码。* 危害：不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行攻击，包括：重放攻击、注入攻击和特权提升等。如何防御1234567对序列化对象执行完整性检查和加密处理，防止被恶意篡改和创建恶意对象。反序列化过程之前执行严格的类型限制。隔离反序列化的代码，将其放在低权限的状态下运行。监视反序列化的过程。 Top9 使用含有已知漏洞的组件应用程序使用带有已知漏洞的组件会破坏应用程序防御系统，可能导致严重的数据丢失或服务器接管 如何防御1234567移除不用的依赖、功能组件等。监控CVE，NVD等是否发布已使用组件的相关漏洞信息仅从官方渠道获取组件。监控不在维护的库和组件等。 Top10 不足的日志记录和监控不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。如：未对登录、登录失败和高额交易等记录可审计性事件进行记录；告警和错误事件未能产生或产生不完整的日志信息。 防御：12345确保所有登录、访问控制失败、输入验证失败能够被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐户，并为后期取证预留足够时间。建立有效的检测和告警机制，使可疑的活动在可接受的时间内被发现并应对。建立或采取一个应急响应机制和恢复计划。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://na1r.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"OWASP","slug":"OWASP","permalink":"https://na1r.com/tags/OWASP/"}]},{"title":"HTTrack Website Copie","slug":"HTTrack Website Copie","date":"2019-02-27T23:25:13.000Z","updated":"2019-03-10T11:58:34.000Z","comments":true,"path":"2019/02/28/HTTrack Website Copie/","link":"","permalink":"https://na1r.com/2019/02/28/HTTrack%20Website%20Copie/","excerpt":"HTTrack 是一款既免费又实用的工具，它能创建和目标网站一样的离线脱机副本。内容包括原始网站的所有网页、链接、图片等。作用是为了减少与目标系统交互,避免触发目标系统的报警机制。","text":"HTTrack 是一款既免费又实用的工具，它能创建和目标网站一样的离线脱机副本。内容包括原始网站的所有网页、链接、图片等。作用是为了减少与目标系统交互,避免触发目标系统的报警机制。 HTTrack 安装1apt-get install webhttrack Kali Linux 自己带。 HTTrack 使用1httrack","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://na1r.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://na1r.com/tags/Linux/"},{"name":"HTTrack","slug":"HTTrack","permalink":"https://na1r.com/tags/HTTrack/"}]},{"title":"Web应用程序渗透测试思路","slug":"Web应用程序渗透测试思路","date":"2019-02-24T05:31:13.000Z","updated":"2019-03-11T13:51:52.000Z","comments":true,"path":"2019/02/24/Web应用程序渗透测试思路/","link":"","permalink":"https://na1r.com/2019/02/24/Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%80%9D%E8%B7%AF/","excerpt":"一般规范一些字符在HTTP请求的不同位置具有不同含义。当修改请求中的数据时，应该对这些字符进行URL编码，以确保应用程序按照想要的方式解释这些字符。","text":"一般规范一些字符在HTTP请求的不同位置具有不同含义。当修改请求中的数据时，应该对这些字符进行URL编码，以确保应用程序按照想要的方式解释这些字符。 &amp;用分割URL查询字符串与消息主体中的参数，要插入字面量&amp;字符，必须将其转换成URL编码 %26。 =用于分割URL查询字符串与消息主体中每个参数的名称与值，所以要插入字面量=字符时要URL编码%3d。 ?用于标记URL查询字符串的起始位置。要插入字面量需要URL编码%3f。 空格用于在请求的第一行中标记URL的结束位置，并可用于Cookie消息头中表示一个cookie值结束。要插入一个字面两空格字符必须将其转换成%20或+。 因为+表示一个编码的空格，要插入一个字面量+字符，需编码为%2b。 ；用于在Cookie消息头中分隔单个Cookie。要插入字面量+字符，必须将其编码为%3b。 #用于在URL中标记片段标识符。如果在浏览器的URL中输入这个字符，他将会传送给服务器的URL截短。要插入需将其编码为%23。 %在URL编码方案中作为前缀。要插入字面量%字符，必须将其编码为%25。 1此外要注意的是，在表单中输入URL编码的数据通常会导致浏览器执行另一层编码。例如在表单中提交%00可能会导致想服务器发送值%2500。为此，通常最好是在拦截代理服务器中查看最终请求。 1许多查找常见Web应用程序的测试需要发送各种专门设计的输入字符串，并监控应用程序的响应，从中搜索表示漏洞存在的反常现象。有时，无论是否提交某个特定漏洞的触发器，应用程序对一个特殊请求的响应都将包含这个漏洞的签名。只要提交专门设计的特殊输入导致了与某个漏洞有关的行为（如一个特殊的错误消息），就应该重新核查，确定在相关参数中提交良性输入是否也会造成相同的行为。如果两种输入的行为相同，那么最初的发现可能是一个错误警报。 解析应用程序内容搜索可见的 配置浏览器，使用首先集成代理/抓取工具。可以使用Burp监控和解析有代理服务器处理的Web内容。 配置浏览器，监控和分析被浏览器处理的HTTP和HTML内容。 以常规的方法应用程序，访问发现的每个链接URL,提交每一个表单并执行全部多阶段功能。尝试激活与禁用JS,激活与禁用Cookie的情况下浏览。 如果应用程序使用身份验证，并且渗透测试人员拥有帐号，或可以注册帐号，那么就可以使用该帐号访问受保护的内容。 当浏览，监控通过拦截代理服务器的请求与响应时，了解被提交的数据种类，了解客户端是如何控制服务器端的应用程序的行为。 检查被动抓取生成的站点地图，确定任何尚未使用浏览器访问到的内容或功能。 完成手动浏览和被动抓取后，可以用一组发现的URL作为种子，使用爬虫抓取应用程序。有时候可以发现手动浏览时尚未发现的内容。 浏览公共资源 使用因特网搜索引擎和历史档案。 使用高级搜索语法提高搜索效率。 搜索在应用程序内容中发现的任何姓名和电子邮箱地址等。包括新闻和分组搜索等。 检查任意已发布的WSDL文件（ WebServices Description Language (WSDL Web服务语言)是一个用于精确描述Web Service的文档格式。），以生成应用程序可能采用的功能名称和参数值列表。 发现隐藏的内容 确定应用程序如何处理访问不存在的资源的请求。手动提交一些请求，访问已知有效和无效的资源，比较对这些请求的响应。找到一种确定资源并不存在的方法。 获取常见文件与目录名以及常见的文件扩展名列表。根据这些内容设法推断出其他内容，假如有a.php，c.php 那可以推断出有c.php。 审查所有客户端代码，确定任何与服务器端内容（包括HTML注释和禁用的表单元素）有关线索。 使用自动化技巧，根据目录名，文件名，文件扩展名列表提出大量请求，监控应用程序的相应。 查找默认的内容 探查所有默认或已知存在的内容，使用NIKTO的选项提高探查的效率。 手动核查所有可能有用的发现，减少探查结果中的错误警报。 枚举标识符指定的功能确定任何通过在请求参数中提交一个功能标识符访问特殊应用程序功能的情况。（如 admin.jsp/login.php） 调试参数 选择一个或几个使用隐藏调试参数（如debug=true）的应用程序或页面或功能，他们最有可能出现在，登录，搜索，文件上传下载等功能上。 使用常用调试参数名（debug、test、hide、source）与常用参数值（true、yes、on、1）列表，排出键值对组合，可使用Burp。 在应用程序的响应中查找任何表示添加的参数对应用程序的行为造成影响的反常现象。 分析应用程序确定功能 确定为使应用程序正常运行而建立的核心功能以及每项功能旨在执行的操作。 确定应用程序采用的核心安全机制以及他们的工作机制。如了解处理身份验证、会话管理、与访问控制的关键机制以及支持他们的功能、如用户注册和账户恢复。 确定所有外围功能和行为，如重定向，站外链接，错误消息，管理与日志功能。 确定数据进入点 确定在应用程序中引入用户输入的所有进入点，URL、查询字符串参数、POST数据、cookie与其他应用程序处理的HTTP消息头。 分析应用程序使用的所有定制数据传输或编码机制，如非常规的查询字符串格式。 去定所有应用程序中引入用户控制或其他第三方数据的外带通道，如处理显示SMTP收到的消息的Web邮件应用。 确定所使用的技术 确定，如果表单、脚本、Cookie、控件等不同技术。 尽可能确定服务器端使用的技术，包括脚本语言、应用程序平台、数据库、邮件系统等。 网站指纹识别。 解析受攻击面 设法去定服务器端应用程序的内部结果与功能以及用于实现客户端可见行为的后台机制。 确定各种与每一项功能有关的常见漏洞。 定制攻击计划，优先考虑最有用的功能以及与它有关的最严重的潜在漏洞。 测试客户端控件通过客户端传送数据 在应用程序中，确定隐藏的表单字段、cookie和URL参数明显用于通过客户端传送数据的所有情况。 检查逻辑错误 测试验证机制 了解验证机制 确定应用程序使用的验证技术。 确定所有与验证有关的功能。 如果应用程序为采用自动自我注册机制，确定是否可以使用任何其他地方获得几个用户账户。 测试密码强度 在应用程序中查找有关用户密码最小强度规则的说明。 尝试使用所有自我注册或密码修改功能，设定各种脆弱密码，确定应用程序实际应用的密码强度尝试。 测试不完整的证书确认。 爆破。 测试用户名枚举可使用Burp批量跑，然后查看返回的结果对比不同。 测试密码猜测的适应性使用有效用户名和无效用户的请求。监控应用程序的响应，确定他们之间的所有差异。如果测试多次失败还没返回任何锁定账户的消息，再提交一个正确的包含有效证书的请求。如果这个请求成功，那说明应用程序没采用任何账户锁定策略。 这个时候就可以批量跑爆破了。 测试账户恢复功能 查看是否有忘记密码功能 使用一个帐号完成账户恢复的功能，了解运作机制。 查看是否有密保机制，并且尝试找出容易猜测出答案的问题。 查看是否有暗示功能。如果有尝试上面。 是否为发送邮件完成帐号恢复，确定是否控制邮件。 测试“记住我”功能 如果有记住我功能，激活并分析他的作用，并且仔细查找可能存在的漏洞。 检查记住我功能设定的所有持久性cookie。寻找任何明确表示出用户身份或明显包含可预测的用户标识符的数据。 即使其中保存的数据经过严密编码或模糊处理，也要仔细分析这些数据，并比较“记住”几个非常类似的用户名和密码的结果，找到逆向的机会。 根据上面的结果，适当修改cookie，尝试登录。 测试伪装功能 如果应用包含任何明确的功能，允许伪装成另一名用户，那么仔细审查，查找是否越权漏洞存在。 尝试伪装成管理。 尝试用户名唯一性 尝试用不同的密码注册相同的账户 如果被阻止，就可以枚举出注册用户名 如果可以注册多个相同账户，分析这个情况，尝试修改一个用户名的密码，使其与另外一个相同，然后登录。 测试证书的可预测性 如果用户名或密码有应用程序自动生成，设法获得几个相连的用户名或密码。确定任何可探测顺序或模式。 如果生成的用户名可预测，那么就可以推断出有效的用户名。 检测不安全的证书传输 遍历所有需要传输证书，与验证有关的功能，登录、注册、密码修改等等。拦截查看所有流量。 查看是否加密传输。 查看证书是否保存在cookie中，有可能导致XSS攻击 是否为HTTPS加载登录表单，如果不是，那么可能会遭受到中间人攻击。 测试不安全的证书分配 确定应用程序如何想新用户分配证书。常用的方法如电子邮件等。 如果应用程序分配账户激活URL，尝试注册几个紧密相连的新账户，并确定收到的URL中的顺序。如果有规律，尝试预测后续或最近的用户的URL，尝试占有他们的账户。 尝试多次重复使用同一个URL，看看应用程序是允许这么做。确定这种方式是否可以给一个已经激活的账户设定一个新密码。 测试不安全的存储 如果可以访问散列密码，应检查共享同一个散列密码值的账户。尝试以采用最常用的散列值的密码登录。 使用相关散列算法或彩虹表查找明文值。 测试逻辑缺陷1.测试故障开放条件 对于要求应用程序检查用户证书的每一项功能（包括登录与密码修改功能），使用受控制的账户以正常方式访问这些功能。注意它们提交给应用程序的每一项请求参数。 连续多次重复以上过程，以各种无法预料的方式轮流修改每一项参数，破坏应用程序的逻辑，对每一个参数进行以下修改。 提交一个空字符串值。 完全删除名/值对。 提交非常长和非常短的值。 提交字符串代替数字或提交数字代替字符串。 以相同和不同的值，多次提交同一个命名参数。 检查上述的请求的响应，如果出现任何无法预料的差异，对这个结果进行进一步测试。 2.测试多阶段处理机制 如果任何与验证有关的功能需要在一系列不同的请求中提交证书，确定每个阶段的主要目的，同时注意每个阶段提交的参数。 多次重复上述步骤，修改提交请求的顺序，破坏应用程序的逻辑。相关测试包括： 以不同顺序完成所有阶段，到达想要的那个阶段。 轮流直接进入每一个阶段，然后按正常顺序访问后续步骤。 几次访问上述功能，轮流省略每一个阶段，然后在后一个阶段继续按正常的顺序访问。 根据观察到的结果及每个功能阶段的主要目的，尝试通过其他方式修改访问这些阶段的顺序，并访问开发者没有预料到的阶段。 做开发者没想到的事。 利用漏洞获取为授权访问 尝试以另一名用户的身份进行验证，最好是管理员 爆破时要考虑密码强度规则以及密码确认机制的完整性，避免浪费。 可使用Burp搞定。 未完待续来自 《黑客攻防技术宝典-Web实战篇(The Web Application Hacker’s Handbook Version2)》","categories":[{"name":"读书分享","slug":"读书分享","permalink":"https://na1r.com/categories/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://na1r.com/tags/Linux/"},{"name":"规范","slug":"规范","permalink":"https://na1r.com/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"Kunpeng","slug":"Kunpeng","date":"2019-02-17T04:32:23.000Z","updated":"2019-03-10T11:58:56.000Z","comments":true,"path":"2019/02/17/Kunpeng/","link":"","permalink":"https://na1r.com/2019/02/17/Kunpeng/","excerpt":"简介Kunpeng是一个Golang编写的开源POC检测框架，集成了包括数据库、中间件、web组件、cms等等的漏洞POC，可检测弱口令、SQL注入、XSS、RCE等漏洞类型，以动态链接库的形式提供调用，通过此项目可快速对目标进行安全漏洞检测，比攻击者快一步发现风险漏洞。","text":"简介Kunpeng是一个Golang编写的开源POC检测框架，集成了包括数据库、中间件、web组件、cms等等的漏洞POC，可检测弱口令、SQL注入、XSS、RCE等漏洞类型，以动态链接库的形式提供调用，通过此项目可快速对目标进行安全漏洞检测，比攻击者快一步发现风险漏洞。 这不是一个POC框架轮子，而是为了解决轮子问题而设计的，也不仅仅只是框架，定位是期望成为一个大家共同维护的漏洞POC库，安全开发人员只需专注于相关安全检测系统的业务逻辑代码实现，而不必各自重复的耗费精力维护漏洞库。 运行环境：Windows，Linux，Darwin工作形态：动态链接库，so、dll、go plugin 特点 开箱即用，无需安装任何依赖 跨语言使用，动态链接库形式提供调用 单文件，更新方便，直接覆盖即可 开源社区维护，内置常见漏洞POC 最小化漏洞验证和理论验证，尽量避免攻击行为 使用场景渗透测试辅助工具：例如msf，交互控制台 -&gt; Kunpeng 网络资产安全监控：例如巡风，端口扫描 -&gt; 指纹识别 -&gt; kunpeng 或 nmap -&gt; kunpeng 扫描器： 作为扫描器的漏洞库 更多使用场景可自由发挥 详细： https://github.com/opensec-cn/kunpeng 感谢大佬的无私分享","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://na1r.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://na1r.com/tags/Linux/"},{"name":"Windows","slug":"Windows","permalink":"https://na1r.com/tags/Windows/"},{"name":"POC","slug":"POC","permalink":"https://na1r.com/tags/POC/"}]},{"title":"Fail2ban 阻止SSH爆破","slug":"Fail2ban 阻止SSH爆破","date":"2019-01-22T00:52:52.000Z","updated":"2019-03-10T11:58:06.000Z","comments":true,"path":"2019/01/22/Fail2ban 阻止SSH爆破/","link":"","permalink":"https://na1r.com/2019/01/22/Fail2ban%20%E9%98%BB%E6%AD%A2SSH%E7%88%86%E7%A0%B4/","excerpt":"简介Fail2ban可以监视你的系统日志，匹配日志的错误信息执行相应的屏蔽动作。","text":"简介Fail2ban可以监视你的系统日志，匹配日志的错误信息执行相应的屏蔽动作。 安装123yum -y install epel-releaseyum -y install fail2ban 配置规则Fail2ban配置文件在 /etc/fail2ban jail.conf防御配置文件 1234567891011121314151617vi &#x2F;etc&#x2F;fail2ban&#x2F;jail.local[DEFAULT]ignoreip &#x3D; 127.0.0.1&#x2F;8 #IP白名单，白名单中的IP不会屏蔽，可以用（,）分隔填写多个ipbantime &#x3D; 86400 #屏蔽时间-秒findtime &#x3D; 600 #设置多长时间（秒）内超过 maxretry 限制次数即被封锁maxretry &#x3D; 3 #最大尝试次数#这里banaction需要firewallcmd-ipsetbanaction &#x3D; firewallcmd-ipset #屏蔽IP所使用的方法，firewalld，iptablesaction &#x3D; %(action_mwl)s #动作参数[sshd]enabled &#x3D; true # 开启防护，false关闭filter &#x3D; sshd #过滤规则名称，对应 filter.d 目录下的 sshd.confport &#x3D; 22 #对应的端口action &#x3D; %(action_mwl)s #动作参数logpath &#x3D; &#x2F;var&#x2F;log&#x2F;secure #监控的日志路径 使用systemctl start fail2ban启动Fail2ban 同一个IP，在10分钟内，如果连续超过3次错误，则使用Firewalld Ban掉该IP。 输入：fail2ban-client status sshd 查看被Ban掉的IP。","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://na1r.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://na1r.com/tags/Linux/"},{"name":"Fail2ban","slug":"Fail2ban","permalink":"https://na1r.com/tags/Fail2ban/"},{"name":"SSH","slug":"SSH","permalink":"https://na1r.com/tags/SSH/"}]},{"title":"Typecho在Apache环境下开启伪静态","slug":"Typecho在Apache环境下开启伪静态","date":"2018-12-27T06:55:52.000Z","updated":"2019-03-10T12:00:16.000Z","comments":true,"path":"2018/12/27/Typecho在Apache环境下开启伪静态/","link":"","permalink":"https://na1r.com/2018/12/27/Typecho%E5%9C%A8Apache%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%BC%80%E5%90%AF%E4%BC%AA%E9%9D%99%E6%80%81/","excerpt":"12345本文环境:CentOS7.3Apache 2.4.6PHP 5.4.16网站存放位置: &#x2F;var&#x2F;www&#x2F;html","text":"12345本文环境:CentOS7.3Apache 2.4.6PHP 5.4.16网站存放位置: &#x2F;var&#x2F;www&#x2F;html 1、修改Apache的rewrite模块vi /etc/httpd/conf/httpd.conf 找到httpd.conf中是否包含LoadModule rewrite_module modules/mod_rewrite.so如果没有就自己加一个 增加配置如下: 12345&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&quot;&gt; Order allow,deny Allow from all AllowOverride All&lt;&#x2F;Directory&gt; 2、修改.htaccess文件路径：/var/www/html/.htaccess，如果没有就新建一个将以下内容添加进去。 1234567&lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteBase &#x2F; RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteRule ^(.*)$ index.php [E&#x3D;PATH_INFO:$1] &lt;&#x2F;IfModule&gt; 重启apache 3、开启网站地址重写功能 如果提示“重写功能检测失败, 请检查你的服务器设置” 勾上继续就行","categories":[{"name":"分享经验","slug":"分享经验","permalink":"https://na1r.com/categories/%E5%88%86%E4%BA%AB%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://na1r.com/tags/Linux/"},{"name":"Apache","slug":"Apache","permalink":"https://na1r.com/tags/Apache/"},{"name":"Typecho","slug":"Typecho","permalink":"https://na1r.com/tags/Typecho/"}]},{"title":"NetEase-MusicBox","slug":"NetEase-MusicBox","date":"2018-12-26T04:32:23.000Z","updated":"2019-03-11T08:42:46.000Z","comments":true,"path":"2018/12/26/NetEase-MusicBox/","link":"","permalink":"https://na1r.com/2018/12/26/NetEase-MusicBox/","excerpt":"基于Python编写的 高品质网易云音乐命令行版本","text":"基于Python编写的 高品质网易云音乐命令行版本 安装Ubuntu/Debian123$ (sudo) pip install NetEase-MusicBox$ (sudo) apt-get install mpg123 可选依赖aria2 用于缓存歌曲libnotify-bin 用于支持消息提示（Linux平台）pyqt python-dbus dbus qt 用于支持桌面歌词 使用1$ musicbox 参考来源：musicbox","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://na1r.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://na1r.com/tags/Linux/"},{"name":"终端","slug":"终端","permalink":"https://na1r.com/tags/%E7%BB%88%E7%AB%AF/"},{"name":"音乐","slug":"音乐","permalink":"https://na1r.com/tags/%E9%9F%B3%E4%B9%90/"}]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://na1r.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"分享经验","slug":"分享经验","permalink":"https://na1r.com/categories/%E5%88%86%E4%BA%AB%E7%BB%8F%E9%AA%8C/"},{"name":"工具分享","slug":"工具分享","permalink":"https://na1r.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"},{"name":"读书分享","slug":"读书分享","permalink":"https://na1r.com/categories/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"elk","slug":"elk","permalink":"https://na1r.com/tags/elk/"},{"name":"日志分析","slug":"日志分析","permalink":"https://na1r.com/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"name":"C语言","slug":"C语言","permalink":"https://na1r.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"图书","slug":"图书","permalink":"https://na1r.com/tags/%E5%9B%BE%E4%B9%A6/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://na1r.com/tags/Wireshark/"},{"name":"流量","slug":"流量","permalink":"https://na1r.com/tags/%E6%B5%81%E9%87%8F/"},{"name":"抓包","slug":"抓包","permalink":"https://na1r.com/tags/%E6%8A%93%E5%8C%85/"},{"name":"Webshell","slug":"Webshell","permalink":"https://na1r.com/tags/Webshell/"},{"name":"一句话木马","slug":"一句话木马","permalink":"https://na1r.com/tags/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"},{"name":"中国菜刀","slug":"中国菜刀","permalink":"https://na1r.com/tags/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80/"},{"name":"过Waf","slug":"过Waf","permalink":"https://na1r.com/tags/%E8%BF%87Waf/"},{"name":"分块传输","slug":"分块传输","permalink":"https://na1r.com/tags/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/"},{"name":"插件","slug":"插件","permalink":"https://na1r.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"Linux","slug":"Linux","permalink":"https://na1r.com/tags/Linux/"},{"name":"美化","slug":"美化","permalink":"https://na1r.com/tags/%E7%BE%8E%E5%8C%96/"},{"name":"加固","slug":"加固","permalink":"https://na1r.com/tags/%E5%8A%A0%E5%9B%BA/"},{"name":"mysql","slug":"mysql","permalink":"https://na1r.com/tags/mysql/"},{"name":"日志清除","slug":"日志清除","permalink":"https://na1r.com/tags/%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4/"},{"name":"linux","slug":"linux","permalink":"https://na1r.com/tags/linux/"},{"name":"OWASP","slug":"OWASP","permalink":"https://na1r.com/tags/OWASP/"},{"name":"HTTrack","slug":"HTTrack","permalink":"https://na1r.com/tags/HTTrack/"},{"name":"规范","slug":"规范","permalink":"https://na1r.com/tags/%E8%A7%84%E8%8C%83/"},{"name":"Windows","slug":"Windows","permalink":"https://na1r.com/tags/Windows/"},{"name":"POC","slug":"POC","permalink":"https://na1r.com/tags/POC/"},{"name":"Fail2ban","slug":"Fail2ban","permalink":"https://na1r.com/tags/Fail2ban/"},{"name":"SSH","slug":"SSH","permalink":"https://na1r.com/tags/SSH/"},{"name":"Apache","slug":"Apache","permalink":"https://na1r.com/tags/Apache/"},{"name":"Typecho","slug":"Typecho","permalink":"https://na1r.com/tags/Typecho/"},{"name":"终端","slug":"终端","permalink":"https://na1r.com/tags/%E7%BB%88%E7%AB%AF/"},{"name":"音乐","slug":"音乐","permalink":"https://na1r.com/tags/%E9%9F%B3%E4%B9%90/"}]}